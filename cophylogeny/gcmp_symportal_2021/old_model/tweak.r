newargs <- commandArgs(trailingOnly = TRUE)

load(file.path(newargs[[1]], 'primary_sampling', 'setup.RData'))

outdir <- file.path(newargs[[1]], newargs[[2]])

dir.create(outdir)
outfile <- file(file.path(outdir, 'runlog.log'), open = 'wt')
sink(outfile, type = 'output', split = T)
outfileerr <- file(file.path(outdir, 'runlogerr.log'), open = 'wt')
sink(outfileerr, type = 'message')

library(ape)
library(phytools)
library(phangorn)
library(reshape2)
library(parallel)
library(rstan)
library(RColorBrewer)
library(paleotree)
library(ggplot2)
library(geosphere) ##not sure this is being used? would be for an implementation of geographic covariance
library(geiger) ##?
library(shinystan) ##?
library(nlme) ##?
library(picante) ##?
library(Matrix)##?

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())


## model options
aveStDMetaPriorExpect <- as.numeric(newargs[[3]])

sm <- stan_model(modelPath)

## run the model!
runStanModel()

## re-fit the model but shuffle the samples (to see if there are any biases generated by the sampling design)
runStanModel(shuffleSamples = T)

## re-fit the model but ignore all data (sampling from prior to see if there are any biases generated by the model itself)
runStanModel(noData = T)

## re-fit the model but shuffle the data at the observation level (to see if there are any biases generated by the sampling design)
runStanModel(shuffleData = T)

## fin
